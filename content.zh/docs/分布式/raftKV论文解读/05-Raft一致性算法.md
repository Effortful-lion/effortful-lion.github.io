---
title: "05-Raft一致性算法"
weight: 1
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: true
# bookComments: false
# bookSearchExclude: false
# bookHref: ''
# bookIcon: ''
---

# Raft 一致性算法

### Raft算法的简略设计

主要是算法角色、方法、参数、算法过程的定义：下面有个图分别解释了对全局节点（以及特定节点）的属性、RPC调用的方法和参数以及逻辑过程

![](/assets/Raft一致性算法-1769421830382.png)
![](/assets/Raft一致性算法-1769422012709.png)

![](/assets/Raft一致性算法-1769421863938.png)
![](/assets/Raft一致性算法-1769421988140.png)

![](/assets/Raft一致性算法-1769421876478.png)
![](/assets/Raft一致性算法-1769421944960.png)

![](/assets/Raft一致性算法-1769421892424.png)
![](/assets/Raft一致性算法-1769422042502.png)

### Raft特性
![](/assets/Raft一致性算法-1769422088144.png)
简记：
- 领导人唯一
- 领导人只能日志追加
- 日志匹配（有相同日志内容的节点）
- 提交日志不丢失（通过主节点的选举规则，强制新主节点 “继承所有已提交日志”）
- 如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（已经应用的日志条目不会被覆盖）

## Raft基础

### Raft的状态/角色

- 领导者
- 候选人
- 跟随着

### 角色职责

- 领导者：1. 提供服务 2. 心跳检测 3. 日志复制
- 候选人：1. 发起投票
- 跟随着：1. 投票 2. 日志复制

### 状态/角色转换关系

服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会
变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导人。在一个任期内，领导
人一直都会是领导人，直到自己宕机了：

![](/assets/05-Raft一致性算法-1769426488547.png)
或者看：
![](/assets/05-Raft一致性算法-1769427227899.png)

任期时间：
- 任期连续 —— 用连续的序号表示
- 任期从选举开始，从任期/选举失败（无领导人）结束（意味着：一个任期里领导者为 0 或者 1）
- 任期号全局递增
- 节点的任期号（每次通信，发现比自己大的）自动更新（候选人/领导人会退回跟随者）
- 发现任期号小的请求，直接拒绝
![](/assets/05-Raft一致性算法-1769427451957.png)

### 节点间通信形式/方法

形式：RPC

方法（2+1）：
1. 请求投票：候选人发起，跟随者响应，选举期间
2. 附加条目：leader发起，跟随者响应（正常情况下，一个集群中只有 Leader + Follower）（leader失联，follower发起选举）
3. 传输快照：（并行发送请求 + 无响应请求重试）== 效率 + 可靠

### 领导选举过程

...

### 日志复制

1. leader 提供服务时：
- 记录日志
- 发起RPC附加日志
- 当被安全复制后，应用到自己的状态机将结果返回到客户端、同步所有跟随者的日志（重试保证所有跟随者最终都存储了该日志）**无限后台异步重试（不会丢弃）**

2. committed entries：已提交条目（一致性判定标志）表示已被多数节点确认的日志条目，不会丢失、修改、覆盖，可以安全应用到状态机执行
![](/assets/05-Raft一致性算法-1769429869983.png)
提交时间：leader创建的日志条目被多数派节点复制成功后，就会被提交（当前日志条目和之前所有的日志条目）

3. 日志匹配特性：
- 如果在**不同的日志**中的两个条目拥有**相同的索引和任期号**，那么他们**存储了相同的指令**。（leader在一个任期中的指定的一个索引位置最多创建一条日志，并且日志位置不会改变）
- 如果在**不同的日志**中的两个条目拥有**相同的索引和任期号**，那么他们**之前的所有日志条目也全部相同**（一致性检查：leader发送附加日志时携带：前一个日志的任期+索引号）

4. 正常情况下，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。但是leader的崩溃，可能会使日志出现不一致的状态：（甚至在一系列的leader/follower崩溃下加剧）：
![](/assets/05-Raft一致性算法-1769431051813.png)
新leader和follower之间的日志条目相互都有出入
![](/assets/05-Raft一致性算法-1769431137257.png)
![](/assets/05-Raft一致性算法-1769431300022.png)
每个任期的最小索引处进行一致性校验，替代从第一个nextIndex开始每个索引处进行一致性校验：
![](/assets/05-Raft一致性算法-1769431385662.png)
所以，新leader只需要正常操作进行附加条目的RPC，通过RPC时的一致性校验，自动进行检查后就会慢慢相同。同时：
![](/assets/05-Raft一致性算法-1769431616717.png)

### 安全性

前面描述了 选举 和 日志复制，但是仍然存在问题：

1. 我们的选举规则： 超时控制+FIFO的选举规则+多数人选举+随机选举时间 
2. 但是，如果此时让一个日志很少的节点获得了leader，那么根据一致性检验就会覆盖其他节点的可提交日志条目。
3. 但是，可提交日志条目很有可能被部分节点应用到状态机（尤其是旧leader应用后且响应给客户端），此时就会存在数据不一致性（不同客户端看到了不同的数据）

#### 选举限制

领导人完整特性：这是提出的解决上述问题的机制。目的选出日志最新的节点作为leader（继承前面leader的日志）。

方式：raft的日志方向唯一（leader -> follower）所以不会将旧日志从follower传送到新leader（说白了，就是直接选出来最新的）
1. 发起投票 RPC 时，请求中包含候选者的最新日志信息（任期号+索引号）
2. 跟随者不是 简单的**FIFO** ，而是 **FIFO+新旧日志校验** ，如果 候选者 的**任期号小**或者**任期号相同 + 索引小**，那么 跟随者 拒绝投票

#### 提交之前任期的日志条目

概念：
1. 日志回滚：就是未提交的日志，撤销提交操作（或者说直接覆盖/删除）。（简单说，这个未提交日志没了）

背景：
1. 旧任期（比如任期 2）的日志 2，被 Leader 通过多数派确认直接标记为已提交（图 c 中 S1、S2、S5 有日志 2，满足多数派）；
2. 但此时 Leader（S1）又崩溃，新 Leader（S5）的日志里没有日志 2（S5 只有 1、3）；
3. 新 Leader（S5）在同步时，会通过一致性检查，把 S1、S2、S3、S4 中已提交的日志 2覆盖 / 删除（图 d 中日志 2 被替换成 3）；
4. 结果：已提交的日志 2 被回滚，破坏了 “已提交日志永不丢失” 的安全性。

解决办法：
1. 禁止直接提交旧任期日志：不再通过多数派确认直接提交旧任期（如任期 2）的日志 2；
2. 只直接提交当前任期日志：新 Leader（S1 恢复后）生成当前任期（比如任期 4）的新日志 4，通过多数派确认直接提交日志 4；
3. 间接提交旧日志：由于日志匹配特性（前缀必须一致），日志 4 提交时，其前面的所有日志（包括旧任期的日志 2）会被连带间接提交；
4. 结果：日志 2 被 “绑定” 到当前任期的已提交日志 4 上，后续任何 Leader 都必须包含日志 4（选举规则），因此也必须包含日志 2，日志 2 永远不会被回滚（图 e 中日志 2 被保留，日志 4 被提交）。

图示：问题的产生和解决（对raft论文的原图理解）
![](/assets/05-Raft一致性算法-1769436423976.png)

#### 安全性论证

**这里是论证：** 已提交的日志，永远不会丢失，所有未来的 Leader 都一定包含它。

**回忆：**领导人完整性（就是 **新leader一定继承旧leader的提交了的日志条目** / **集群中所有已经提交（committed）的日志条目**）

**证明方法：**反证法，通过假设不存在领导人完整性

**假设：**
- 任期 T 的 Leader（记为 Leader T）提交了一条日志 L
- 但存在某个未来任期 U（U > T）的 Leader（Leader U），它的日志里没有 L
- 并且 U 是第一个不包含 L 的 Leader（最小的 U > T）（任期U就是第一个不包含已提交日志的未来的leader）

**推出矛盾：**这样的leader不可能存在

**根据背景可以推出已知：**
1. 选举时 Leader U 没有 L（因为 Leader 从不删 / 覆盖日志）
   Leader 只会追加日志，不会删除或覆盖
   所以 Leader U 当选时，日志里就没有 L
2. 两个 “多数派” 必有交集（核心数学点）
   Leader T 提交 L → L 被复制到多数派节点（记为集合 A）
   Leader U 当选 → 从多数派节点获得选票（记为集合 B）
   两个多数派集合 A、B 必有交集（数学上：任意两个多数派一定相交）
   所以：至少有一个节点 S，既收到了 L，又给 Leader U 投了票
   这个 S 就是 “矛盾的关键节点”。
3. S 投票给 U 时，一定还保存着 L
   S 先收到 Leader T 的 L（因为 L 已提交）
   S 给 U 投票前，任期 ≤ U
   中间任何 Leader 都包含 L（因为 U 是第一个不包含 L 的 Leader）
   Leader 从不删日志，Follower 只在和 Leader 冲突时才删
   所以：S 投票给 U 时，日志里一定还有 L

投票条件：U 的日志必须 ≥ S 的日志（新旧判定）

矛盾点：
1. U == S
- 既然U得到票了 => U的长度>=S
- 但是 S有之前的+L ，U有之前的但是没有L（并且不能有日志空洞），所以U一定要有L。才至少使得长度和S相等。那么矛盾了（我们假设的是U没有L）

2. U > S
- U > S,（U是第一个没有L的）那么前一个leader V一定有L，U >= V >= S ,回到1了，U也必须有L才能大于V

#### 跟随者和候选者崩溃

二者处理方式相同：
1. 直接崩溃，领导者无限重试RPC
2. 执行了RPC，还没来得及响应崩溃了；领导者重试RPC（无所谓，RPC幂等，再次执行，不会出现重复日志条目，直接忽略）

#### 时间和可用性

**Raft 时间相关核心规则简洁总结**
1. **核心原则**：安全性与时间无关（不会因事件快慢出错误），可用性（需要选举成功）依赖时间（时间不满足则无法稳定提供服务）；
2. **选举稳定的核心时间不等式**：**广播时间（心跳机制） ≪ 选举超时时间 ≪ 平均故障间隔时间**（三个时间需相差一个及以上数量级）；
3. **各时间定义**
    - 广播时间：单节点并行发RPC给集群所有节点并接收响应的平均时间；
    - 选举超时时间：跟随者触发选举的超时阈值；
    - 平均故障间隔时间：单服务器两次故障的平均间隔；
4. **不等式的意义**
    - 广播时间远小于选举超时：Leader能及时发心跳阻止跟随者发起选举，避免无意义竞选；
    - 选举超时远小于平均故障间隔：系统因Leader崩溃导致的不可用时间（约等于选举超时）占比极低，保证整体稳定性；
5. **时间配置特点**
    - 广播时间、平均故障间隔由系统/硬件决定，选举超时可自主配置；
    - 实际配置参考：广播时间0.5~20ms，选举超时10~500ms，服务器平均故障间隔多为数月及以上，易满足要求。
